<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- Mandatory for mobile responsiveness -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Duck Hunt Pro (Silent)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /*
        Cross-Platform Base Styles
        */
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #2c3e50;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
            cursor: none; /* Hide default cursor */
            user-select: none;
            -webkit-user-select: none;
        }

        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        #gameContainer {
            width: 95vw; /* Fluid width */
            max-width: 800px; /* Desktop max size */
            aspect-ratio: 4/3;
            background: linear-gradient(to bottom, #87CEEB 0%, #87CEEB 70%, #6B8E23 70%, #6B8E23 100%);
            border: 8px solid #333;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
            position: relative;
            overflow: hidden;
            border-radius: 5px;
            cursor: none;
            /* Allow touch for targeting and shooting */
            touch-action: manipulation;
        }

        /* Responsive UI elements (Increased size for mobile readability) */
        #scoreBoard, #shotsDisplay {
            font-size: 0.9rem; /* Slightly larger base font */
            padding: 8px 12px; /* Increased padding */
            color: white;
            text-shadow: 2px 2px 0 #000;
        }

        /* Adjust font size on smaller screens using media query for better readability */
        @media (max-width: 600px) {
            #scoreBoard, #shotsDisplay {
                font-size: 0.75rem;
                padding: 5px 8px;
            }
            #messageBox h2 {
                font-size: 1.5rem;
            }
            #messageBox p {
                font-size: 0.8rem;
            }
        }

        .duck {
            width: 70px;
            height: 50px;
            background-color: #FFA500;
            border-radius: 50% 50% 0 0;
            transition: transform 0.1s ease-out;
            pointer-events: auto;
            cursor: none;
            z-index: 10;
            position: absolute;
            /* Simple duck shape using CSS pseudo-elements */
            border: 2px solid #000;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
        }
        
        .duck::before, .duck::after {
            content: '';
            position: absolute;
        }

        .duck::before { /* Head (Green) */
            width: 25px;
            height: 25px;
            top: -12px;
            left: 5px;
            background-color: #008000;
            border-radius: 50%;
            border: 2px solid #000;
        }

        .duck::after { /* Beak (Red) */
            width: 12px;
            height: 6px;
            top: 5px;
            left: 25px;
            background-color: #FF4500;
            border-radius: 0 5px 5px 0;
        }

        /* Visual feedback when shot */
        .duck.shot {
            background-color: #999;
            opacity: 0.5;
            animation: fall 1s forwards;
        }

        @keyframes fall {
            to {
                transform: translateY(100vh) rotate(5deg);
                opacity: 0.1;
            }
        }

        /* CROSSHAIR LOGIC: Visible only on Desktop/Mouse devices */
        #crosshair {
            position: absolute;
            width: 40px;
            height: 40px;
            border: 3px solid white;
            border-radius: 50%;
            box-shadow: 0 0 8px rgba(255, 255, 255, 1);
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 100;
            background-color: rgba(255, 255, 255, 0.3);
            /* Initially hidden, only displayed if a mouse is detected (desktop) */
            display: none;
        }

        /* Media query to detect desktop/mouse environment */
        @media (hover: hover) and (pointer: fine) {
            #crosshair {
                display: block;
            }
        }

        #messageBox {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            z-index: 1000;
            width: 80%;
            max-width: 450px;
            border: 5px solid #f9d71c;
            box-shadow: 0 0 25px rgba(255, 255, 255, 0.8);
        }

        #messageBox h2 {
            font-size: 1.8rem;
            margin-bottom: 10px;
            color: #f9d71c;
        }

        #messageBox p {
            font-size: 0.9rem;
            margin-bottom: 25px;
        }
        
        /* Removed startButton styles as the button is gone */
    </style>
</head>
<body>

<div id="gameContainer">
    <div id="crosshair"></div>
    <div id="scoreBoard" class="absolute top-0 left-0">SCORE: 0</div>
    <div id="shotsDisplay" class="absolute top-0 right-0">SHOTS: 3</div>

    <div id="messageBox">
        <h2 id="messageTitle">Duck Hunt Pro</h2>
        <p id="messageText">Tap/Click anywhere to begin the hunt! You need to hit 60% of the ducks to progress to the next round.</p>
        <!-- Removed startButton -->
    </div>
</div>

<script>
    const gameContainer = document.getElementById('gameContainer');
    const crosshair = document.getElementById('crosshair');
    const scoreBoard = document.getElementById('scoreBoard');
    const shotsDisplay = document.getElementById('shotsDisplay');
    const messageBox = document.getElementById('messageBox');
    const messageTitle = document.getElementById('messageTitle');
    const messageText = document.getElementById('messageText');
    // startButton is no longer needed

    let score = 0;
    let shotsRemaining = 3;
    let ducksOnScreen = [];
    let spawnInterval;
    let gameState = 'START';
    let lastTime = 0;
    let ducksToSpawnThisRound = 5;
    let totalDucksInRound = 0; // NEW: Tracks the total to be spawned for accurate end-of-round check
    let ducksShotThisRound = 0;
    let currentRound = 0;

    const DUCK_SPEED_BASE = 50;
    const DUCK_MAX_SPEED = 200;
    const DUCK_SIZE = 70;
    const DUCK_HEIGHT = 50;

    // --- Game Object Class ---
    class Duck {
        constructor() {
            this.element = document.createElement('div');
            this.element.classList.add('duck');
            gameContainer.appendChild(this.element);

            this.reset();
            this.element.style.left = `${this.x}px`;
            this.element.style.top = `${this.y}px`;
        }

        reset() {
            const side = Math.random() < 0.5 ? 'left' : 'right';
            this.x = side === 'left' ? -DUCK_SIZE : gameContainer.clientWidth;
            this.y = Math.random() * (gameContainer.clientHeight * 0.7 - DUCK_HEIGHT) + (gameContainer.clientHeight * 0.1);
            
            // Speed increases with each round
            this.speed = (Math.random() * (DUCK_MAX_SPEED - DUCK_SPEED_BASE) + DUCK_SPEED_BASE) * (1 + (currentRound - 1) * 0.2);
            
            this.directionX = side === 'left' ? 1 : -1;
            this.directionY = Math.random() < 0.5 ? 1 : -1;
            this.isShot = false;
            this.element.classList.remove('shot');
            this.element.style.opacity = 1;
            // Flip the duck element to face the direction of travel
            this.element.style.transform = `scaleX(${this.directionX > 0 ? 1 : -1})`;
        }

        update(deltaTime) {
            if (this.isShot) return;

            // Move horizontally
            this.x += this.directionX * this.speed * deltaTime;

            // Simple vertical movement
            this.y += this.directionY * (this.speed * 0.5) * deltaTime;

            // Bounce off top/bottom boundaries
            const skyHeightLimit = gameContainer.clientHeight * 0.7 - DUCK_HEIGHT;
            if (this.y < 0) {
                this.y = 0;
                this.directionY *= -1;
            } else if (this.y > skyHeightLimit) {
                this.y = skyHeightLimit;
                this.directionY *= -1;
            }

            // Update visual position
            this.element.style.left = `${this.x}px`;
            this.element.style.top = `${this.y}px`;

            // Check if duck flew off screen
            if (this.x < -DUCK_SIZE || this.x > gameContainer.clientWidth + DUCK_SIZE) {
                this.element.remove();
                return 'escaped';
            }
            return 'flying';
        }

        handleHit() {
            if (this.isShot || gameState !== 'PLAYING') return;

            this.isShot = true;
            this.element.classList.add('shot');
            // No sound effect
            score += 100 * currentRound;
            ducksShotThisRound++;
            updateScoreBoard();
            this.element.style.pointerEvents = 'none';

            // Remove duck after it falls
            setTimeout(() => {
                if (this.element.parentNode === gameContainer) {
                    this.element.remove();
                }
            }, 1000);
        }
    }

    // --- Game Logic ---

    function updateScoreBoard() {
        scoreBoard.textContent = `SCORE: ${score}`;
        shotsDisplay.textContent = `SHOTS: ${shotsRemaining}`;
    }

    function spawnDuck() {
        if (ducksToSpawnThisRound > 0) {
            const newDuck = new Duck();
            ducksOnScreen.push(newDuck);
            ducksToSpawnThisRound--;
        } else if (ducksOnScreen.length === 0) {
            // Check round end only if no more ducks are left to spawn
            checkRoundEnd();
        }
    }

    function gameLoop(currentTime) {
        if (gameState !== 'PLAYING') return;

        const deltaTime = (currentTime - lastTime) / 1000;
        lastTime = currentTime;

        // Update ducks
        for (let i = ducksOnScreen.length - 1; i >= 0; i--) {
            const duck = ducksOnScreen[i];
            const status = duck.update(deltaTime);
            if (status === 'escaped' || (duck.isShot && duck.element.parentNode === null)) {
                ducksOnScreen.splice(i, 1);
            }
        }

        // Check if all ducks are gone and new ducks need to be spawned
        if (ducksOnScreen.length === 0 && ducksToSpawnThisRound === 0) {
             checkRoundEnd();
        }

        requestAnimationFrame(gameLoop);
    }

    function startRound() {
        currentRound++;
        
        // Calculate total ducks for the round and store it separately
        totalDucksInRound = Math.min(10, 5 + currentRound);
        ducksToSpawnThisRound = totalDucksInRound;

        ducksShotThisRound = 0;
        shotsRemaining = 3;
        
        // Clear previous ducks
        ducksOnScreen.forEach(duck => duck.element.remove());
        ducksOnScreen = [];
        
        updateScoreBoard();
        messageBox.classList.add('hidden');
        gameState = 'PLAYING';
        lastTime = performance.now();
        requestAnimationFrame(gameLoop);

        // Calculate spawn rate (gets faster each round)
        const spawnDelay = Math.max(500, 2500 - (currentRound * 300));

        spawnDuck(); // Spawn the first duck immediately
        spawnInterval = setInterval(spawnDuck, spawnDelay);
    }

    function checkRoundEnd() {
        // This function should only run once all ducks (spawned and flying) are gone.
        if (ducksToSpawnThisRound === 0 && ducksOnScreen.length === 0) {
            clearInterval(spawnInterval);
            
            // Use totalDucksInRound to calculate required hits
            const requiredHits = Math.ceil(totalDucksInRound * 0.6); 

            if (ducksShotThisRound >= requiredHits) {
                messageTitle.textContent = `ROUND ${currentRound} COMPLETE!`;
                // Updated text: tell the user to tap/click
                messageText.innerHTML = `Great shooting! You hit ${ducksShotThisRound}/${totalDucksInRound} ducks (Need ${requiredHits}). Tap/Click anywhere for Round ${currentRound + 1}!`;
                messageBox.classList.remove('hidden');
                gameState = 'ROUND_COMPLETE';
            } else {
                endGame();
            }
        }
    }

    function endGame() {
        gameState = 'GAME_OVER';
        cancelAnimationFrame(gameLoop);
        clearInterval(spawnInterval);
        messageTitle.textContent = "GAME OVER!";
        // Updated text: tell the user to tap/click
        messageText.innerHTML = `Final Score: ${score}<br>You made it to Round ${currentRound}. Tap/Click anywhere to play again!`;
        messageBox.classList.remove('hidden');

        ducksOnScreen.forEach(duck => duck.element.remove());
        ducksOnScreen = [];
    }

    // --- Event Listeners (Adaptive Input) ---

    // Function to get accurate game container boundaries for collision checking
    function getGameRect() {
        return gameContainer.getBoundingClientRect();
    }

    // 1. Desktop/Mouse Crosshair Tracking
    gameContainer.addEventListener('mousemove', (e) => {
        const rect = getGameRect();
        crosshair.style.left = `${e.clientX - rect.left}px`;
        crosshair.style.top = `${e.clientY - rect.top}px`;
    });

    // 2. Mobile/Touch Crosshair Tracking (for better feel)
    gameContainer.addEventListener('touchmove', (e) => {
        if (e.touches.length > 0) {
            const rect = getGameRect();
            const touch = e.touches[0];
            crosshair.style.left = `${touch.clientX - rect.left}px`;
            crosshair.style.top = `${touch.clientY - rect.top}px`;
            e.preventDefault();
        }
    }, { passive: false });


    // 3. Handle shooting (Click/Tap) - MODIFIED TO INCLUDE START/RESTART LOGIC
    gameContainer.addEventListener('click', (e) => {
        // --- START/RESTART/NEXT ROUND Logic (runs first) ---
        if (gameState === 'START' || gameState === 'GAME_OVER') {
            score = 0;
            currentRound = 0;
            startRound();
            return;
        } else if (gameState === 'ROUND_COMPLETE') {
            startRound();
            return;
        }
        // ---------------------------------------------------

        if (gameState !== 'PLAYING') return;

        if (shotsRemaining > 0) {
            shotsRemaining--;
            updateScoreBoard();

            const rect = getGameRect();
            const clickX = e.clientX;
            const clickY = e.clientY;

            // Create a temporary shot splash effect (SIZE INCREASED for better touch visibility)
            const splash = document.createElement('div');
            splash.style.cssText = `
                position: absolute;
                width: 20px; /* Larger for better touch target visibility */
                height: 20px;
                background-color: rgba(255, 0, 0, 0.8); /* Slightly opaque red */
                border-radius: 50%;
                transform: translate(-50%, -50%);
                z-index: 99;
                box-shadow: 0 0 10px #ff0000;
            `;
            splash.style.left = `${clickX - rect.left}px`;
            splash.style.top = `${clickY - rect.top}px`;
            gameContainer.appendChild(splash);
            setTimeout(() => splash.remove(), 300);

            let hitSomething = false;
            for (const duck of ducksOnScreen) {
                const duckRect = duck.element.getBoundingClientRect();

                // Collision Check
                if (clickX >= duckRect.left && clickX <= duckRect.right &&
                    clickY >= duckRect.top && clickY <= duckRect.bottom && !duck.isShot) {
                    duck.handleHit();
                    hitSomething = true;
                    break;
                }
            }

            // Check end conditions
            // If out of shots AND all ducks are either spawned/shot/escaped, check round end.
            if (shotsRemaining === 0 && ducksToSpawnThisRound === 0 && ducksOnScreen.length === 0) {
                checkRoundEnd();
            } else if (shotsRemaining === 0 && ducksToSpawnThisRound > 0) {
                 // If the player runs out of shots before all ducks have spawned, it's game over.
                endGame();
            }
        }
    });

    // Removed startButton click listener

    // Initial setup on window load
    window.addEventListener('load', () => {
        messageBox.classList.remove('hidden');
        updateScoreBoard();
    });

</script>

</body>
</html>
