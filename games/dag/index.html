<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Drift Racer</title>
    <!-- Tailwind CSS is included but custom styles are used for the game aesthetic -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Base Styling */
        body {
            background-color: #1a1a2e; /* Deep purple background */
            color: #00ffff; /* Neon cyan text */
            font-family: 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
            touch-action: none; /* Crucial for preventing mobile scrolling/zooming */
        }

        /* Game Container - Fixed Aspect Ratio */
        #game-container {
            width: 100vw;
            height: 100vh;
            max-width: 500px; /* Maximize visibility on desktop while retaining mobile feel */
            max-height: 900px;
            position: relative;
            background-color: #000;
            overflow: hidden;
            border: 4px solid #ff007f; /* Neon pink border */
            box-shadow: 0 0 20px rgba(255, 0, 127, 0.7);
        }

        /* Canvas */
        #game-canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI Overlay */
        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            font-size: 1.2rem;
            text-shadow: 0 0 5px #00ffff;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), rgba(0,0,0,0));
        }

        /* Game Over Screen */
        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 10;
        }

        #game-over.active {
            display: flex;
        }

        #game-over h2 {
            font-size: 2.5rem;
            color: #ff007f;
            text-shadow: 0 0 15px #ff007f;
            margin-bottom: 20px;
        }

        #final-score {
            font-size: 1.8rem;
            color: #00ffff;
            margin-bottom: 30px;
            text-shadow: 0 0 10px #00ffff;
        }

        .action-button {
            padding: 12px 25px;
            font-size: 1.1rem;
            background-color: #00ffff;
            color: #1a1a2e;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 0 10px #00ffff;
            font-weight: bold;
        }

        .action-button:hover {
            background-color: #ff007f;
            color: #fff;
            box-shadow: 0 0 15px #ff007f;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <!-- Game Over Overlay -->
        <div id="game-over">
            <h2>CRASHED!</h2>
            <div id="final-score">SCORE: 0</div>
            <button id="restart-button" class="action-button">RACE AGAIN</button>
        </div>

        <!-- Score and Speed UI -->
        <div id="ui-overlay">
            <span id="score">SCORE: 0</span>
            <span id="speed">SPEED: 0.0</span>
        </div>

        <canvas id="game-canvas"></canvas>
    </div>

    <script>
        // --- CORE SETUP ---
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('game-container');
        const scoreDisplay = document.getElementById('score');
        const speedDisplay = document.getElementById('speed');
        const gameOverOverlay = document.getElementById('game-over');
        const finalScoreText = document.getElementById('final-score');
        const restartButton = document.getElementById('restart-button');

        // Game State
        let gameRunning = false;
        let animationFrameId;

        // Game Variables
        let score = 0;
        let baseSpeed = 5; // Initial downward speed (pixels per frame)
        let currentSpeed = baseSpeed;
        let speedMultiplier = 0.005; // How much speed increases per frame
        let obstacles = [];
        let lastObstacleTime = 0;
        let spawnInterval = 60; // Frames between spawning new obstacles

        // Canvas Dimensions (Set in resizeCanvas)
        let GAME_WIDTH, GAME_HEIGHT;

        // Player Car Object
        const player = {
            width: 40, 
            height: 70,
            x: 0,
            y: 0, // Fixed Y position
            lane: 1, // 0=Left, 1=Center, 2=Right
            color: '#FF007F', // Neon Pink
        };

        // Road Configuration (3 Lanes)
        const LANE_COUNT = 3;
        let laneWidth;

        // --- GAME OBJECTS ---

        class Obstacle {
            constructor(lane) {
                this.width = player.width * 1.1; // Slightly larger than player to feel imposing
                this.height = player.height * 1.1;
                this.lane = lane;
                // Calculate starting X position based on lane
                this.x = this.getLaneCenter(lane) - this.width / 2;
                this.y = -this.height; // Start above the screen
                this.color = ['#FFFF00', '#00FFFF', '#00FF00'][Math.floor(Math.random() * 3)]; // Yellow, Cyan, Green
            }

            getLaneCenter(l) {
                return (l + 0.5) * laneWidth;
            }

            draw() {
                const w = this.width;
                const h = this.height;
                const x = this.x;
                const y = this.y;

                // 1. Main Body (Obstacle Color) - Slightly boxier/truck-like shape
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.moveTo(x + w * 0.1, y);         // Top-left
                ctx.lineTo(x + w * 0.9, y);         // Top-right
                ctx.lineTo(x + w * 0.95, y + h);    // Bottom-right (wider base)
                ctx.lineTo(x + w * 0.05, y + h);    // Bottom-left (wider base)
                ctx.closePath();
                ctx.fill();

                // 2. Window/Cabin (Dark Grey)
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.beginPath();
                ctx.moveTo(x + w * 0.2, y + h * 0.2);
                ctx.lineTo(x + w * 0.8, y + h * 0.2);
                ctx.lineTo(x + w * 0.85, y + h * 0.4);
                ctx.lineTo(x + w * 0.15, y + h * 0.4);
                ctx.closePath();
                ctx.fill();

                // 3. Headlights (White/Yellow)
                ctx.fillStyle = '#FFFFAA';
                const lightSize = w * 0.1;
                ctx.fillRect(x + lightSize * 0.5, y + h * 0.9, lightSize, lightSize * 0.5);
                ctx.fillRect(x + w - lightSize * 1.5, y + h * 0.9, lightSize, lightSize * 0.5);
            }

            update() {
                this.y += currentSpeed;
            }
        }

        // --- DRAWING FUNCTIONS ---

        function drawRoad() {
            // Draw background road color (dark grey)
            ctx.fillStyle = '#2d2d3a';
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            // Draw lane dividers (neon lines)
            ctx.strokeStyle = '#FFFFFF'; // White lines
            ctx.lineWidth = 5;
            const lineDash = [15, 30]; // Dashed line pattern
            
            // Draw 2 dividing lines for 3 lanes
            for (let i = 1; i < LANE_COUNT; i++) {
                const lineX = i * laneWidth;
                
                // Animate dash pattern to simulate movement
                const dashOffset = (score * 0.1) % (lineDash[0] + lineDash[1]);
                ctx.setLineDash(lineDash);
                ctx.lineDashOffset = -dashOffset;

                ctx.beginPath();
                ctx.moveTo(lineX, 0);
                ctx.lineTo(lineX, GAME_HEIGHT);
                ctx.stroke();
            }
            ctx.setLineDash([]); // Reset dash pattern
        }

        function drawPlayer() {
            // Recalculate player X based on current lane
            const targetX = (player.lane + 0.5) * laneWidth - player.width / 2;
            
            // Smoother movement: Interpolate player position towards the target lane center
            // Interpolation factor increased from 0.3 to 0.5 for faster, snappier lane changes
            player.x += (targetX - player.x) * 0.5; 

            const w = player.width;
            const h = player.height;
            const x = player.x;
            const y = player.y;
            
            // 1. Main Body (Neon Pink) - Sporty trapezoid shape
            ctx.fillStyle = player.color;
            ctx.beginPath();
            ctx.moveTo(x + w * 0.1, y);         // Top-left (slimmer front)
            ctx.lineTo(x + w * 0.9, y);         // Top-right (slimmer front)
            ctx.lineTo(x + w, y + h);           // Bottom-right
            ctx.lineTo(x, y + h);               // Bottom-left
            ctx.closePath();
            ctx.fill();

            // 2. Cockpit/Window (Cyan)
            ctx.fillStyle = '#00FFFF'; // Neon Cyan
            ctx.beginPath();
            ctx.moveTo(x + w * 0.25, y + h * 0.2);
            ctx.lineTo(x + w * 0.75, y + h * 0.2);
            ctx.lineTo(x + w * 0.85, y + h * 0.5);
            ctx.lineTo(x + w * 0.15, y + h * 0.5);
            ctx.closePath();
            ctx.fill();

            // 3. Tail/Engine Glow (Brighter Pink)
            ctx.fillStyle = '#FF44AA';
            ctx.fillRect(x + w * 0.1, y + h * 0.9, w * 0.8, h * 0.1);
        }

        function drawGame() {
            ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            
            drawRoad();
            drawPlayer();
            obstacles.forEach(o => o.draw());
        }

        // --- GAME LOGIC ---

        function updateGame() {
            // 1. Increase Speed and Score
            currentSpeed += speedMultiplier;
            score += Math.round(currentSpeed * 0.1);
            
            // 2. Obstacle Spawning
            lastObstacleTime++;
            
            // Calculate dynamic spawn interval (faster speed = faster spawning)
            const dynamicSpawnInterval = Math.max(25, 60 - Math.floor(currentSpeed * 3)); 

            if (lastObstacleTime > dynamicSpawnInterval) {
                // Randomly select a lane
                let lane = Math.floor(Math.random() * LANE_COUNT);
                obstacles.push(new Obstacle(lane));
                lastObstacleTime = 0;
            }

            // 3. Update Obstacles and check for removal
            obstacles.forEach(o => o.update());
            obstacles = obstacles.filter(o => o.y < GAME_HEIGHT);

            // 4. Collision Detection
            checkCollisions();
            
            // 5. Update UI
            updateUI();
        }

        function checkCollisions() {
            const px1 = player.x;
            const py1 = player.y;
            const px2 = player.x + player.width;
            const py2 = player.y + player.height;

            for (const o of obstacles) {
                const ox1 = o.x;
                const oy1 = o.y;
                const ox2 = o.x + o.width;
                const oy2 = o.y + o.height;

                // Simple AABB collision check
                if (px1 < ox2 && px2 > ox1 && py1 < oy2 && py2 > oy1) {
                    endGame();
                    return;
                }
            }
        }
        
        // --- GAME FLOW ---

        function gameLoop() {
            if (!gameRunning) return;

            // 1. Update Game State
            updateGame();

            // 2. Draw Frame
            drawGame();

            // 3. Loop
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function startGame() {
            // Ensure correct sizing and game reset before starting
            resizeCanvas(); 
            resetGame();
            
            gameRunning = true;
            gameOverOverlay.classList.remove('active');
            gameLoop();
        }

        function endGame() {
            gameRunning = false;
            cancelAnimationFrame(animationFrameId);
            
            finalScoreText.textContent = `FINAL SCORE: ${score}`;
            gameOverOverlay.classList.add('active');
        }

        function resetGame() {
            score = 0;
            currentSpeed = baseSpeed;
            obstacles = [];
            lastObstacleTime = 0;
            player.lane = 1;
            updateUI();
        }

        function updateUI() {
            scoreDisplay.textContent = `SCORE: ${score}`;
            speedDisplay.textContent = `SPEED: ${(currentSpeed).toFixed(1)}`;
        }

        // --- RESPONSIVENESS & RESIZING ---

        function resizeCanvas() {
            // Set canvas size to match container size
            GAME_WIDTH = container.clientWidth;
            GAME_HEIGHT = container.clientHeight;

            canvas.width = GAME_WIDTH;
            canvas.height = GAME_HEIGHT;

            // Calculate Lane width based on new canvas size
            laneWidth = GAME_WIDTH / LANE_COUNT;

            // Adjust player dimensions and fixed position (using a ratio for responsiveness)
            // Changed from GAME_WIDTH / 9 to GAME_WIDTH / 12 to make the car narrower
            player.width = Math.max(30, GAME_WIDTH / 12); 
            player.height = Math.max(60, GAME_HEIGHT / 6);
            
            // Recalculate obstacle size based on the new smaller player size
            obstacles.forEach(o => {
                o.width = player.width * 1.1;
                o.height = player.height * 1.1;
                // Recenter obstacle X to the new lane center
                o.x = o.getLaneCenter(o.lane) - o.width / 2;
            });

            player.y = GAME_HEIGHT - player.height * 1.5;
            
            // Re-center player in the starting lane
            player.x = (player.lane + 0.5) * laneWidth - player.width / 2;
            
            // Redraw to adjust road lines instantly
            if (gameRunning) {
                drawGame();
            }
        }
        
        // --- INPUT HANDLER (MOBILE & DESKTOP) ---
        
        let isTouching = false;
        let startX = 0;

        function getClientX(e) {
            return e.touches ? e.touches[0].clientX : e.clientX;
        }

        function handleInputStart(e) {
            e.preventDefault();
            if (!gameRunning) return;

            isTouching = true;
            startX = getClientX(e);
            handleInputMove(e); // Allow instant movement on tap
        }

        function handleInputMove(e) {
            e.preventDefault();
            if (!isTouching || !gameRunning) return;

            const clientX = getClientX(e);
            
            // Convert touch/mouse X position to a lane index
            const rect = canvas.getBoundingClientRect();
            const canvasX = clientX - rect.left;
            
            // Determine the intended lane based on X position
            let intendedLane = Math.floor(canvasX / laneWidth);
            
            // Clamp lane index to bounds [0, 2]
            player.lane = Math.min(LANE_COUNT - 1, Math.max(0, intendedLane));
        }

        function handleInputEnd(e) {
            e.preventDefault();
            isTouching = false;
        }

        // --- EVENT LISTENERS ---

        window.addEventListener('load', () => {
             // Initial setup call
            resizeCanvas();
            startGame();
        });
        window.addEventListener('resize', resizeCanvas); 

        // Touch Listeners for Mobile Control
        canvas.addEventListener('touchstart', handleInputStart, { passive: false });
        canvas.addEventListener('touchmove', handleInputMove, { passive: false });
        canvas.addEventListener('touchend', handleInputEnd, { passive: false });
        canvas.addEventListener('touchcancel', handleInputEnd, { passive: false });
        
        // Mouse Listeners for Desktop Control
        canvas.addEventListener('mousedown', handleInputStart, { passive: false });
        canvas.addEventListener('mousemove', handleInputMove, { passive: false });
        canvas.addEventListener('mouseup', handleInputEnd, { passive: false });
        canvas.addEventListener('mouseleave', handleInputEnd, { passive: false });

        restartButton.addEventListener('click', startGame);

    </script>
</body>
</html>
