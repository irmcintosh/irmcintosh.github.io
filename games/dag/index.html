<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arcade Racer</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* Retro Arcade Styling */
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #000033; /* Dark Blue/Space background */
            color: #FF00FF; /* Magenta for contrast */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 10px;
            overflow: hidden;
            user-select: none;
        }

        /* Game Container - Ensures responsiveness and fixed aspect ratio */
        #game-container {
            width: 95vw; /* Start wide for mobile */
            max-width: 400px; /* Max width for desktop */
            aspect-ratio: 3 / 5; /* Fixed aspect ratio for arcade look (W:H) */
            border: 4px solid #00FFFF; /* Cyan border */
            box-shadow: 0 0 15px #00FFFF, 0 0 25px rgba(0, 255, 255, 0.5);
            border-radius: 8px;
            overflow: hidden;
            background-color: #000; /* Black canvas background */
            position: relative;
        }

        /* Canvas - Fill container */
        #game-canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none; /* Crucial: Prevents mobile browsers from scrolling/zooming */
        }

        /* Info Display */
        #info-bar {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 8px;
            background-color: rgba(0, 0, 0, 0.5);
            font-size: 0.7rem;
            text-shadow: 0 0 3px #00FFFF;
        }

        /* Game Over Overlay */
        #game-over-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 10;
        }

        #game-over-overlay.active {
            display: flex;
        }

        #game-over-overlay h2 {
            font-size: 1.5rem;
            color: #FF0077;
            text-shadow: 0 0 8px #FF0077;
            margin-bottom: 10px;
        }

        #final-score-text {
            font-size: 1.1rem;
            color: #00FF77;
            margin-bottom: 20px;
        }

        #restart-button {
            padding: 8px 16px;
            font-size: 0.9rem;
            font-family: 'Press Start 2P', cursive;
            color: #000000;
            background-color: #00FFFF;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 0 8px #00FFFF;
        }

        #restart-button:hover {
            background-color: #FF0077;
            box-shadow: 0 0 12px #FF0077;
        }

        /* Mobile Controls Overlay - Invisible touch zones */
        #mobile-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 40%; /* Only use bottom part for touch area */
            z-index: 5; /* Below game over, above canvas */
            display: flex;
            justify-content: space-between;
        }

        .control-area {
            width: 50%;
            height: 100%;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <!-- Game Over Overlay -->
        <div id="game-over-overlay">
            <h2>CRASHED!</h2>
            <p id="final-score-text">Distance: 0m</p>
            <button id="restart-button">RETRY</button>
        </div>

        <div id="info-bar">
            <span id="score">DISTANCE: 0m</span>
            <span id="speed">SPEED: 0 MPH</span>
        </div>

        <canvas id="game-canvas"></canvas>

        <!-- Invisible Mobile Touch Controls -->
        <div id="mobile-controls">
            <div id="left-control" class="control-area"></div>
            <div id="right-control" class="control-area"></div>
        </div>
    </div>

    <script>
        // --- CONSTANTS AND SETUP ---
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('game-container');
        const scoreDisplay = document.getElementById('score');
        const speedDisplay = document.getElementById('speed');
        const gameOverOverlay = document.getElementById('game-over-overlay');
        const finalScoreText = document.getElementById('final-score-text');
        const restartButton = document.getElementById('restart-button');
        const leftControl = document.getElementById('left-control');
        const rightControl = document.getElementById('right-control');

        // Base dimensions for fixed game logic
        const BASE_WIDTH = 300;
        const BASE_HEIGHT = 500;
        
        let GAME_WIDTH = BASE_WIDTH;
        let GAME_HEIGHT = BASE_HEIGHT;
        let scaleFactor = 1;

        let gameRunning = false;
        let animationFrameId;

        // Game state variables (scaled at initialization)
        let roadLineY = 0;
        let score = 0;
        let speed = 0;
        let obstacleSpawnTimer = 0;

        // Configuration based on scaleFactor (set in resetGame)
        let PLAYER_CAR_WIDTH;
        let PLAYER_CAR_HEIGHT;
        let PLAYER_SPEED;
        let LANE_WIDTH;
        let MAX_SPEED = 10;
        let ACCELERATION = 0.05;
        let DRAG = 0.01;
        let OBSTACLE_BASE_SPEED;

        // --- GAME OBJECTS ---

        class Car {
            constructor(isPlayer = false, lane = 1) {
                this.isPlayer = isPlayer;
                // Dimensions initialized in resetGame/resizeCanvas
                this.width = 0; 
                this.height = 0;
                this.lane = lane; // 0, 1, or 2 (Left, Center, Right)
                this.color = isPlayer ? '#00FF00' : (Math.random() > 0.5 ? '#FF0077' : '#FFFF00');
                
                // Position set dynamically
                this.x = 0;
                this.y = 0; 
            }

            getLaneX(lane) {
                const centerOffset = GAME_WIDTH / 2;
                const halfCar = this.width / 2;
                // LANE_WIDTH is calculated in resetGame
                
                // These offsets rely on LANE_WIDTH being accurately calculated based on current scale
                if (lane === 0) return centerOffset - LANE_WIDTH - halfCar; // Left
                if (lane === 1) return centerOffset - halfCar; // Center
                if (lane === 2) return centerOffset + LANE_WIDTH - halfCar; // Right
                return centerOffset - halfCar; // Default to center
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                // Simple window detail (scaled)
                ctx.fillStyle = '#000000';
                const windowHeight = this.height * 0.3;
                const windowY = this.y + this.height * 0.2;
                const windowX = this.x + this.width * 0.1;
                const windowWidth = this.width * 0.8;
                ctx.fillRect(windowX, windowY, windowWidth, windowHeight);
            }

            update(speed) {
                if (!this.isPlayer) {
                    // Obstacle movement relative to player speed
                    this.y += (OBSTACLE_BASE_SPEED + speed / 5) * scaleFactor;
                }
            }

            move(direction) {
                // Direction: -1 (Left), 1 (Right)
                let newLane = this.lane + direction;
                newLane = Math.max(0, Math.min(2, newLane));
                if (newLane !== this.lane) {
                    this.lane = newLane;
                    this.x = this.getLaneX(this.lane);
                }
            }
        }

        const playerCar = new Car(true, 1);
        let obstacles = [];

        // Method to update car dimensions and position when the screen size changes
        playerCar.resetPosition = function() {
            this.width = PLAYER_CAR_WIDTH;
            this.height = PLAYER_CAR_HEIGHT;
            this.x = this.getLaneX(this.lane);
            this.y = GAME_HEIGHT - this.height * 1.5;
        }


        // --- DRAWING FUNCTIONS ---

        function drawRoad() {
            // Road Surface (Dark Gray)
            ctx.fillStyle = '#111111';
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            // Road Shoulders (Green)
            const shoulderWidth = 40 * scaleFactor;
            ctx.fillStyle = '#00AA00';
            ctx.fillRect(0, 0, shoulderWidth, GAME_HEIGHT);
            ctx.fillRect(GAME_WIDTH - shoulderWidth, 0, shoulderWidth, GAME_HEIGHT);
            
            // Road Lines (White Dashed)
            const lineWidth = 4 * scaleFactor;
            const dashLength = 20 * scaleFactor;
            const gapLength = 20 * scaleFactor;
            const lineX1 = (GAME_WIDTH / 3);
            const lineX2 = (GAME_WIDTH * 2 / 3);

            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = lineWidth;
            ctx.setLineDash([dashLength, gapLength]);

            // Scroll the lines down
            roadLineY = (roadLineY + speed * 1.5 * scaleFactor) % (dashLength + gapLength);

            ctx.lineDashOffset = -roadLineY;

            // Draw center lane dividers (two lines)
            ctx.beginPath();
            ctx.moveTo(lineX1, 0);
            ctx.lineTo(lineX1, GAME_HEIGHT);
            ctx.moveTo(lineX2, 0);
            ctx.lineTo(lineX2, GAME_HEIGHT);
            ctx.stroke();

            ctx.setLineDash([]); // Reset dashed lines
            ctx.lineDashOffset = 0; // Reset offset
        }

        // --- GAME LOGIC ---

        function spawnObstacle() {
            obstacleSpawnTimer += speed / MAX_SPEED;
            const SPAWN_FREQUENCY = 150; // Controls how often an obstacle *might* spawn

            if (obstacleSpawnTimer > SPAWN_FREQUENCY) {
                const lane = Math.floor(Math.random() * 3);
                obstacles.push(new Car(false, lane));
                obstacleSpawnTimer = 0;
            }
        }

        function checkCollision() {
            // Player car bounding box
            const P = playerCar;

            for (let i = 0; i < obstacles.length; i++) {
                const O = obstacles[i];
                
                // AABB Collision Detection
                if (P.x < O.x + O.width &&
                    P.x + P.width > O.x &&
                    P.y < O.y + O.height &&
                    P.y + P.height > O.y) {
                    
                    // Collision detected!
                    endGame();
                    return true;
                }
            }
            return false;
        }

        function updateGame() {
            // 1. Update Speed
            if (speed < MAX_SPEED) {
                speed += ACCELERATION;
            }
            if (speed > MAX_SPEED) { // Apply a little drag if max speed is somehow exceeded
                speed -= DRAG;
            }
            
            // 2. Update Score (Distance)
            score += speed * 0.1;

            // 3. Spawn obstacles
            spawnObstacle();

            // 4. Update Obstacles
            obstacles.forEach(o => o.update(speed));
            
            // Filter obstacles that are off-screen and update their array
            obstacles = obstacles.filter(o => o.y < GAME_HEIGHT);

            // 5. Check Collisions
            if (checkCollision()) return; // Stop update if collision occurred

            // 6. Update UI
            scoreDisplay.textContent = `DISTANCE: ${Math.floor(score)}m`;
            speedDisplay.textContent = `SPEED: ${Math.floor(speed * 10)} MPH`; // Scale speed up for visual effect
        }

        // --- STATE MANAGEMENT ---

        function resetGame() {
            // Recalculate scaled constants
            PLAYER_CAR_WIDTH = 30 * scaleFactor;
            PLAYER_CAR_HEIGHT = 50 * scaleFactor;
            PLAYER_SPEED = 5 * scaleFactor;
            // The 80*scaleFactor accounts for the shoulders on both sides
            LANE_WIDTH = (GAME_WIDTH - 80 * scaleFactor) / 3; 
            OBSTACLE_BASE_SPEED = 2 * scaleFactor; // Base speed of traffic

            // Reset game variables
            score = 0;
            speed = 0;
            roadLineY = 0;
            obstacleSpawnTimer = 0;
            obstacles = [];
            
            // Reset player car position and scale
            playerCar.resetPosition(); 

            // Update UI
            scoreDisplay.textContent = `DISTANCE: 0m`;
            speedDisplay.textContent = `SPEED: 0 MPH`;
        }
        
        function gameLoop() {
            if (!gameRunning) return;

            // 1. Clear Canvas and Draw Road
            drawRoad();

            // 2. Update Game State
            updateGame();

            // 3. Draw Player Car
            playerCar.draw();

            // 4. Draw Obstacles
            obstacles.forEach(o => o.draw());

            // 5. Loop
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function startGame() {
            // Ensure scaling is set up before starting
            resizeCanvas(); 
            resetGame();
            
            gameRunning = true;
            gameOverOverlay.classList.remove('active');
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function endGame() {
            gameRunning = false;
            cancelAnimationFrame(animationFrameId);
            finalScoreText.textContent = `Distance: ${Math.floor(score)}m`;
            gameOverOverlay.classList.add('active');
        }

        function resizeCanvas() {
            // Get the actual rendered width of the container
            const containerWidth = container.clientWidth; 
            const containerHeight = container.clientHeight;

            // Update global game dimensions and scale factor
            GAME_WIDTH = containerWidth;
            GAME_HEIGHT = containerHeight;
            scaleFactor = GAME_WIDTH / BASE_WIDTH; // Scaling based on width

            // Apply dimensions to the canvas element
            canvas.width = GAME_WIDTH;
            canvas.height = GAME_HEIGHT;

            // Recalculate and reset game properties with new scale
            resetGame();
        }

        // --- INPUT HANDLING ---

        let moveIntent = 0; // -1 for left, 1 for right, 0 for none

        function handleInput(direction) {
            // Prevents immediate lane change spamming by checking against the previous intent.
            if (direction !== moveIntent) {
                playerCar.move(direction);
                moveIntent = direction;
            }
        }

        // Handles Keyboard Input (for desktop)
        function handleKey(e) {
            if (e.type === 'keydown') {
                if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') {
                    e.preventDefault();
                    handleInput(-1);
                } else if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') {
                    e.preventDefault();
                    handleInput(1);
                }
            } else if (e.type === 'keyup') {
                if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a' ||
                    e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') {
                    moveIntent = 0;
                }
            }
        }
        
        // Handles Touch End (Crucial for mobile responsiveness)
        function handleTouchEnd() {
            moveIntent = 0;
        }


        // --- EVENT LISTENERS ---
        
        window.addEventListener('load', startGame);
        window.addEventListener('resize', resizeCanvas); 

        document.addEventListener('keydown', handleKey);
        document.addEventListener('keyup', handleKey);

        restartButton.addEventListener('click', startGame);

        // Mobile touch controls listeners: Use the invisible control areas
        leftControl.addEventListener('touchstart', (e) => { e.preventDefault(); handleInput(-1); }, false);
        leftControl.addEventListener('touchend', handleTouchEnd, false);
        rightControl.addEventListener('touchstart', (e) => { e.preventDefault(); handleInput(1); }, false);
        rightControl.addEventListener('touchend', handleTouchEnd, false);
        
        // Stops movement if the finger slides off the control area
        leftControl.addEventListener('touchcancel', handleTouchEnd, false);
        rightControl.addEventListener('touchcancel', handleTouchEnd, false);

    </script>
</body>
</html>
