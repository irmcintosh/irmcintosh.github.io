<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arcade Duck Shooter</title>
    <!-- Tailwind CSS for utility classes (though mostly custom styles are used) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* Retro Arcade Styling */
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #001f3f; /* Deep blue/Cyan background */
            color: #00ff7f; /* Bright Green */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 10px;
            overflow: hidden;
            user-select: none;
            cursor: crosshair; /* Classic shooter cursor */
        }

        /* Game Container */
        #game-container {
            width: 95vw;
            max-width: 500px;
            aspect-ratio: 4 / 3; /* Wider aspect ratio suits shooter games */
            border: 5px solid #00ffff; /* Neon Cyan border */
            box-shadow: 0 0 15px #00ffff, 0 0 25px rgba(0, 255, 255, 0.5);
            border-radius: 8px;
            overflow: hidden;
            background-color: #000;
            position: relative;
        }

        /* Canvas */
        #game-canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none; /* Prevents mobile scrolling/zooming */
        }

        /* Info Display */
        #info-bar {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 8px;
            background-color: rgba(0, 0, 0, 0.7);
            font-size: 0.7rem;
            text-shadow: 0 0 5px #00ff7f;
            z-index: 10;
        }

        /* Game Over Overlay */
        #game-over-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 15;
            padding: 20px;
        }

        #game-over-overlay.active {
            display: flex;
        }

        #game-over-overlay h2 {
            font-size: 1.5rem;
            color: #ff00ff;
            text-shadow: 0 0 8px #ff00ff;
            margin-bottom: 10px;
        }
        
        #game-over-overlay p {
            font-size: 0.8rem;
            color: #00ffff;
            margin-bottom: 5px;
        }

        #final-score-text {
            font-size: 1.2rem;
            color: #00ff7f;
            margin-bottom: 20px;
            text-shadow: 0 0 5px #00ff7f;
        }

        .action-button {
            padding: 10px 20px;
            font-size: 0.8rem;
            font-family: 'Press Start 2P', cursive;
            color: #000000;
            background-color: #ff00ff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 0 10px #ff00ff;
            margin-top: 15px;
        }

        .action-button:hover {
            background-color: #00ffff;
            box-shadow: 0 0 15px #00ffff;
        }

        /* Shot Feedback Indicator */
        .shot-feedback {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: rgba(255, 0, 0, 0.8);
            border: 3px solid white;
            pointer-events: none;
            opacity: 0;
            transform: translate(-50%, -50%);
            transition: transform 0.1s, opacity 0.3s;
            z-index: 20;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <!-- Game Over Overlay -->
        <div id="game-over-overlay">
            <h2>GAME OVER</h2>
            <p>You ran out of ammo!</p>
            <p id="final-score-text">FINAL SCORE: 0</p>
            <p>Hit Ducks: <span id="ducks-hit">0</span> / <span id="total-shots">0</span></p>
            <button id="restart-button" class="action-button">START NEW GAME</button>
        </div>

        <div id="info-bar">
            <span id="score">SCORE: 0</span>
            <span id="ammo">AMMO: 10</span>
        </div>

        <canvas id="game-canvas"></canvas>
    </div>

    <script>
        // --- CONSTANTS AND SETUP ---
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('game-container');
        const scoreDisplay = document.getElementById('score');
        const ammoDisplay = document.getElementById('ammo');
        const gameOverOverlay = document.getElementById('game-over-overlay');
        const finalScoreText = document.getElementById('final-score-text');
        const ducksHitText = document.getElementById('ducks-hit');
        const totalShotsText = document.getElementById('total-shots');
        const restartButton = document.getElementById('restart-button');

        // Base dimensions for scaling game logic
        const BASE_WIDTH = 400;
        const BASE_HEIGHT = 300;
        
        let GAME_WIDTH = BASE_WIDTH;
        let GAME_HEIGHT = BASE_HEIGHT;
        let scaleFactor = 1;

        let gameRunning = false;
        let animationFrameId;

        // Game state variables
        let score = 0;
        let ammo = 10;
        let shotsFired = 0;
        let hitsScored = 0;
        let duckSpawnTimer = 0;
        let ducks = [];

        // --- GAME OBJECTS ---

        class Duck {
            constructor() {
                this.size = 20 * scaleFactor;
                // Start below screen and choose a random color
                this.y = GAME_HEIGHT; 
                this.x = Math.random() * (GAME_WIDTH - this.size);
                
                // Random velocity: Diagonal movement up
                this.vx = (Math.random() > 0.5 ? 1 : -1) * (1 + Math.random() * 1.5) * scaleFactor;
                this.vy = -(1 + Math.random() * 1.5) * scaleFactor;
                
                // Different neon colors for variety
                const colors = ['#FF00FF', '#FFFF00', '#00FFFF', '#FF7700'];
                this.color = colors[Math.floor(Math.random() * colors.length)];
                
                this.alive = true;
                this.points = 100;
            }

            draw() {
                if (!this.alive) return;
                
                // Draw a simple triangular "flying" duck shape
                ctx.fillStyle = this.color;
                ctx.beginPath();
                // Base of the triangle (Duck's body)
                ctx.moveTo(this.x + this.size / 2, this.y);
                ctx.lineTo(this.x + this.size, this.y + this.size);
                ctx.lineTo(this.x, this.y + this.size);
                ctx.closePath();
                ctx.fill();

                // Draw a simple eye (optional detail)
                ctx.fillStyle = '#000000';
                ctx.fillRect(this.x + this.size * 0.6, this.y + this.size * 0.4, 2 * scaleFactor, 2 * scaleFactor);
            }

            update() {
                if (!this.alive) return;
                this.x += this.vx;
                this.y += this.vy;

                // Bounce off side walls
                if (this.x < 0 || this.x + this.size > GAME_WIDTH) {
                    this.vx *= -1;
                }
                
                // If duck flies off the top, it escapes
                if (this.y < -this.size) {
                    this.alive = false;
                }
            }
        }

        // --- GAME LOGIC ---

        function spawnDuck() {
            duckSpawnTimer++;
            const DUCK_SPAWN_RATE = 60; // Spawn new duck every 60 frames (approx 1 second)

            if (duckSpawnTimer > DUCK_SPAWN_RATE && ducks.length < 5) {
                ducks.push(new Duck());
                duckSpawnTimer = 0;
            }
        }

        function updateGame() {
            // 1. Spawn new targets
            spawnDuck();

            // 2. Update and filter targets
            ducks.forEach(d => d.update());
            // Remove ducks that are hit or have flown off-screen
            ducks = ducks.filter(d => d.alive); 
            
            // 3. Check for game over (no ammo remaining)
            if (ammo <= 0 && ducks.length === 0 && gameRunning) {
                endGame();
            }
        }

        function drawGame() {
            // Clear canvas to black
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            // Draw targets
            ducks.forEach(d => d.draw());
        }

        function gameLoop() {
            if (!gameRunning) return;

            // 1. Draw
            drawGame();

            // 2. Update
            updateGame();

            // 3. Loop
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // --- INPUT AND HIT DETECTION ---
        
        // Creates a visual flash where the player clicked
        function drawShotFeedback(x, y, isHit) {
            const indicator = document.createElement('div');
            indicator.classList.add('shot-feedback');
            
            // If it was a hit, make the color bright green
            if (isHit) {
                indicator.style.backgroundColor = 'rgba(0, 255, 127, 0.9)'; // Neon Green
                indicator.style.width = '15px';
                indicator.style.height = '15px';
                indicator.style.border = '2px solid white';
            } else {
                indicator.style.backgroundColor = 'rgba(255, 0, 0, 0.8)'; // Red
            }

            indicator.style.left = `${x}px`;
            indicator.style.top = `${y}px`;
            indicator.style.opacity = '1';

            container.appendChild(indicator);

            // Fade out the indicator quickly
            setTimeout(() => {
                indicator.style.opacity = '0';
                indicator.style.transform = 'scale(2) translate(-25%, -25%)'; // Quick scaling effect
            }, 10);

            // Remove indicator from DOM after transition
            setTimeout(() => {
                indicator.remove();
            }, 500);
        }

        // Handles both mouse click and touch tap
        function handleShootingInput(e) {
            e.preventDefault();
            
            if (!gameRunning) {
                if (gameOverOverlay.classList.contains('active')) {
                     startGame();
                     return;
                }
            }

            if (ammo <= 0) {
                endGame();
                return;
            }

            // Determine if input is touch or mouse
            const inputX = e.type.startsWith('touch') ? e.touches[0].clientX : e.clientX;
            const inputY = e.type.startsWith('touch') ? e.touches[0].clientY : e.clientY;

            // Adjust input coordinates based on canvas position
            const rect = canvas.getBoundingClientRect();
            // Scale the click position to the internal canvas resolution (x/y coordinates for drawing)
            const clickX = inputX - rect.left;
            const clickY = inputY - rect.top;

            ammo--;
            shotsFired++;
            updateUI();

            let hit = false;
            // Iterate backwards to allow removing elements and ensure we only hit the front-most duck
            for (let i = ducks.length - 1; i >= 0; i--) {
                const d = ducks[i];
                // Check if the click is within the duck's bounding box (square simplified for speed)
                if (d.alive && 
                    clickX >= d.x && clickX <= d.x + d.size &&
                    clickY >= d.y && clickY <= d.y + d.size) {
                    
                    d.alive = false;
                    score += d.points;
                    hitsScored++;
                    hit = true;
                    ducks.splice(i, 1); // Remove duck immediately
                    break; // Only one duck per shot (arcade rule)
                }
            }
            
            drawShotFeedback(clickX, clickY, hit);

            if (ammo <= 0) {
                endGame();
            }
        }


        // --- STATE MANAGEMENT ---

        function updateUI() {
            scoreDisplay.textContent = `SCORE: ${score}`;
            ammoDisplay.textContent = `AMMO: ${ammo}`;
        }

        function resetGame() {
            // Recalculate scaled constants
            scaleFactor = GAME_WIDTH / BASE_WIDTH;
            
            // Reset game variables
            score = 0;
            ammo = 20; // Start with 20 shots
            shotsFired = 0;
            hitsScored = 0;
            duckSpawnTimer = 0;
            ducks = [];
            
            updateUI();
        }
        
        function startGame() {
            resizeCanvas(); 
            resetGame();
            
            gameRunning = true;
            gameOverOverlay.classList.remove('active');
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function endGame() {
            gameRunning = false;
            cancelAnimationFrame(animationFrameId);
            
            // Update Game Over screen stats
            finalScoreText.textContent = `FINAL SCORE: ${score}`;
            ducksHitText.textContent = hitsScored;
            totalShotsText.textContent = shotsFired;

            gameOverOverlay.classList.add('active');
        }

        function resizeCanvas() {
            const containerWidth = container.clientWidth; 
            const containerHeight = container.clientHeight;

            GAME_WIDTH = containerWidth;
            GAME_HEIGHT = containerHeight;

            canvas.width = GAME_WIDTH;
            canvas.height = GAME_HEIGHT;
            
            // Recalculate scaling based on width and reset duck sizes
            resetGame(); 
        }

        // --- EVENT LISTENERS ---
        
        window.addEventListener('load', startGame);
        window.addEventListener('resize', resizeCanvas); 

        restartButton.addEventListener('click', startGame);

        // Mobile and Desktop input for shooting
        canvas.addEventListener('click', handleShootingInput, false);
        canvas.addEventListener('touchstart', (e) => { 
            // Only respond to the first touch to prevent multi-fire
            if (e.touches.length === 1) {
                handleShootingInput(e);
            }
        }, false);

    </script>
</body>
</html>
